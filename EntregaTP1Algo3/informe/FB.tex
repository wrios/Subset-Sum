\subsection{Algoritmo}


\begin{codebox}
    \Procname{\proc{FB}(S, int V, int i, int n) \quad\quad\textcolor{green}{O($2^n$)}}
    \li \If $i <= n:$ \quad\quad\textcolor{green}{O($1$)}
        \Then
    \li   
            \Return $min(1+FB(S,V-C_{i},i+1,n),FB(S,V,i+1,n))$
        \End
    \li \If $V = 0:$ \quad\quad\textcolor{green}{O($1$)}
        \Then
    \li        
            \Return $0$
        \End
    \li     \Return $\infinity$

    \end{codebox}

\begin{codebox}
    \Procname{\proc{ResolverFB}(S, int V, int i, int n) \quad\quad\textcolor{green}{O($2^n$)}}
    \li $sol \leftarrow FB(S,V,i+1,n)$
    \li \If $sol = \infinity:$ \quad\quad\textcolor{green}{O($1$)}
        \Then
    \li   
            \Return $-1$
        \End
    \li     \Return $sol$

    \end{codebox}    
\subsection{Correctitud}
El algoritmo recorre todo el espacio de busqueda, lo \'unico que hace es guardar la mejor soluci\'on hasta el momento, y luego devuelve la soluci\'on que tiene o -1 si no encontr\'o soluci\'on.\\
El algoritmo es correcto pues recorre todo el espacio de soluciones y solamente conserva las soluciones v\'alidas y se queda con la mejor.
\subsection{Complejidad}
El algoritmo se divide en dos casos, donde se llama recursivamente con un elemento menos.\\
Definiendo la siguiente ecuaci\'on de recurrencia:\\
$$
T(n) = \left\{
\begin{array}{cl}
 \Theta (1) &\mbox{si
} n = 1 \\
2T(n)+1&\mbox{si } n > 1
\end{array}\right.
$$
\\
Como podemos ver, la recurrencia:\\ $T(n)= 2T(n-1) + 1 = 2(2T(n-1)+1)+1= ...= 2^{n-1}+ (n-1) = O(2^{n})$.\\
Con lo cual tiene complejidad: $O(2^{n})$.\\